var background=(function(){"use strict";function m(c){return c==null||typeof c=="function"?{main:c}:c}const p={serverUrl:"https://api.tyquill.ai",apiUrl:"https://api.tyquill.ai/api",oauthCallbackPath:"/api/auth/callback"},k=()=>p.serverUrl,A=()=>p.apiUrl,E=p.apiUrl,T=()=>`${p.serverUrl}${p.oauthCallbackPath}`,a=globalThis.browser?.runtime?.id?globalThis.browser:globalThis.chrome;class P{constructor(){this.authState={isAuthenticated:!1,user:null,accessToken:null,refreshToken:null,isLoading:!1},this.listeners=[],this.SERVER_URL=k(),this.API_URL=A()}async performOAuthFlow(){const t=await this.getOAuthConfig(),e=await this.openOAuthTab(t.url),i=await this.waitForAuthCode(e);return a.tabs.remove(e.id),i}async getOAuthConfig(){const t=T(),e=await fetch(`${this.API_URL}/auth/google/url?redirectUri=${encodeURIComponent(t)}`);if(!e.ok)throw new Error("Failed to get OAuth URL");return e.json()}async openOAuthTab(t){return new Promise((e,i)=>{a.tabs.create({url:t},u=>{if(a.runtime.lastError){i(new Error(a.runtime.lastError.message));return}if(!u){i(new Error("Failed to create OAuth tab"));return}e(u)})})}async waitForAuthCode(t){return new Promise((e,i)=>{const u=setTimeout(()=>{s(),i(new Error("OAuth timeout"))},3e5),h=(r,n)=>{if(r===t.id&&n.url){const o=new URL(n.url),l=new URL(T());if(o.origin===l.origin&&o.pathname===l.pathname){const f=o.searchParams.get("code"),w=o.searchParams.get("error");if(w){s(),i(new Error(`OAuth error: ${w}`));return}if(f){s(),e(f);return}}}},d=r=>{r===t.id&&(s(),i(new Error("OAuth tab was closed")))},s=()=>{clearTimeout(u),a.tabs.onUpdated.removeListener(h),a.tabs.onRemoved.removeListener(d)};a.tabs.onUpdated.addListener(h),a.tabs.onRemoved.addListener(d)})}async authenticateWithServer(t){const e=T(),i=await fetch(`${this.API_URL}/auth/google/callback`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({code:t,redirectUri:e})});if(!i.ok)throw new Error("Server authentication failed");return i.json()}async login(){try{this.authState.isLoading=!0,this.notifyStateChange();const t=await this.performOAuthFlow(),e=await this.authenticateWithServer(t);return this.authState={isAuthenticated:!0,user:e.user,accessToken:e.accessToken,refreshToken:e.refreshToken,isLoading:!1},await this.saveAuthState(),this.notifyStateChange(),e}catch(t){throw this.authState.isLoading=!1,this.notifyStateChange(),t}}async logout(){try{this.authState.accessToken&&await fetch(`${this.API_URL}/auth/logout`,{method:"POST",headers:{Authorization:`Bearer ${this.authState.accessToken}`}}),this.authState={isAuthenticated:!1,user:null,accessToken:null,refreshToken:null,isLoading:!1},await this.clearAuthState(),this.notifyStateChange()}catch(t){throw t}}async refreshToken(){if(!this.authState.refreshToken&&!await this.restoreAuthState())throw new Error("No refresh token available");try{const t=await fetch(`${this.API_URL}/auth/refresh`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({refreshToken:this.authState.refreshToken})});if(!t.ok)throw new Error("Token refresh failed");const e=await t.json();return this.authState.accessToken=e.accessToken,this.authState.refreshToken=e.refreshToken,this.authState.user=e.user,await this.saveAuthState(),this.notifyStateChange(),e}catch(t){throw await this.logout(),t}}getAuthState(){return{...this.authState}}async getAuthHeaders(){if(!this.authState.accessToken){const t=await this.refreshToken();if(this.authState.accessToken=t.accessToken,!this.authState.accessToken)throw new Error("No access token available")}return{Authorization:`Bearer ${this.authState.accessToken}`,"Content-Type":"application/json"}}async restoreAuthState(){try{const t=await a.storage.local.get(["authState"]);return t.authState?(this.authState=t.authState,this.notifyStateChange(),this.isTokenExpired()&&await this.refreshToken(),!0):!1}catch{return!1}}async saveAuthState(){await a.storage.local.set({authState:this.authState})}async clearAuthState(){await a.storage.local.remove(["authState"])}isTokenExpired(){if(!this.authState.accessToken)return!0;try{const t=JSON.parse(atob(this.authState.accessToken.split(".")[1])),e=Math.floor(Date.now()/1e3);return t.exp<e}catch{return!0}}onAuthStateChange(t){return this.listeners.push(t),()=>{const e=this.listeners.indexOf(t);e>-1&&this.listeners.splice(e,1)}}notifyStateChange(){this.listeners.forEach(t=>t(this.getAuthState()))}}const g=new P;class C{constructor(){this.isRefreshing=!1,this.refreshPromise=null,this.apiUrl=E}async refreshAccessToken(){if(this.isRefreshing&&this.refreshPromise)return await this.refreshPromise,g.getAuthState().accessToken;this.isRefreshing=!0,this.refreshPromise=this.performTokenRefresh();try{await this.refreshPromise;const t=g.getAuthState();if(!t.accessToken)throw new Error("Token refresh failed - no access token received");return t.accessToken}finally{this.isRefreshing=!1,this.refreshPromise=null}}async performTokenRefresh(){try{await g.refreshToken()}catch(t){throw await g.logout(),new Error(`Token refresh failed: ${t instanceof Error?t.message:"Unknown error"}`)}}async request(t,e={}){const{skipAuth:i=!1,...u}=e;try{const h=await g.getAuthHeaders(),d=`${this.apiUrl}${t}`,s={...u,headers:h},r=await fetch(d,s);if(!r.ok){if(r.status===401&&!i)try{const n=await this.refreshAccessToken();h.Authorization=`Bearer ${n}`;const o=await fetch(d,{...s,headers:h});if(!o.ok)throw new Error(`API Error: ${o.status} ${o.statusText}`);return await o.json()}catch(n){throw console.error("❌ Token refresh failed:",n),await g.logout(),new Error("Authentication failed")}throw new Error(`API Error: ${r.status} ${r.statusText}`)}return await r.json()}catch(h){throw h instanceof Error?h:new Error("Unknown API error")}}async get(t,e={}){return this.request(t,{...e,method:"GET"})}async post(t,e,i={}){return this.request(t,{...i,method:"POST",body:e?JSON.stringify(e):void 0})}async put(t,e,i={}){return this.request(t,{...i,method:"PUT",body:e?JSON.stringify(e):void 0})}async patch(t,e,i={}){return this.request(t,{...i,method:"PATCH",body:e?JSON.stringify(e):void 0})}async delete(t,e={}){return this.request(t,{...e,method:"DELETE"})}}const v=new C;class U{async apiRequest(t,e={}){return v.request(t,e)}async createScrap(t){try{return await this.apiRequest("/v1/scraps",{method:"POST",body:JSON.stringify(t)})}catch(e){throw e}}scrapResultToDto(t,e,i){return{url:t.metadata.url,title:t.metadata.title,content:t.content,htmlContent:"",userComment:e,tags:i||[]}}async getScraps(){try{return await this.apiRequest("/v1/scraps",{method:"GET"})}catch(t){throw t}}async deleteScrap(t){try{await this.apiRequest(`/v1/scraps/${t}`,{method:"DELETE"})}catch(e){throw e}}async quickScrap(t,e,i){const u=this.scrapResultToDto(t,e,i);return this.createScrap(u)}async addTagToScrap(t,e){try{return await this.apiRequest(`/v1/scraps/${t}/tags`,{method:"POST",body:JSON.stringify({name:e})})}catch(i){throw i}}async getScrapTags(t){try{return await this.apiRequest(`/v1/scraps/${t}/tags`,{method:"GET"})}catch(e){throw e}}async removeTagFromScrap(t,e){try{await this.apiRequest(`/v1/scraps/${t}/tags/${e}`,{method:"DELETE"})}catch(i){throw i}}}const O=new U,q=m(()=>{let c=!1;a.runtime.onInstalled.addListener(()=>{}),a.action.onClicked.addListener(async s=>{try{await a.sidePanel.open({tabId:s.id,windowId:s.windowId})}catch{}}),a.runtime.onMessage.addListener((s,r,n)=>{if(s.action==="clipAndScrapCurrentPage")return e(r).then(o=>{n({success:!0,data:o})}).catch(o=>{console.error("❌ Background clip and scrap error:",o),n({success:!1,error:o.message})}),!0;if(s.action==="clipCurrentPageForStyle")return i(r).then(o=>{n({success:!0,data:o})}).catch(o=>{console.error("❌ Background clip for style error:",o),n({success:!1,error:o.message})}),!0;if(s.action==="openSidePanel")return t(r).then(()=>{c=!0,n({success:!0})}).catch(o=>{console.error("❌ Background side panel error:",o),n({success:!1,error:o.message})}),!0;if(s.action==="closeSidePanel")return c=!1,n({success:!0}),!0;if(s.action==="getSidePanelState")return n({success:!0,isOpen:c}),!0;if(s.action==="sidePanelClosed")return c=!1,n({success:!0}),!0});async function t(s){try{if(s.tab?.id)await a.sidePanel.open({tabId:s.tab.id});else throw new Error("No tab ID available")}catch(r){throw console.error("❌ Background: Failed to open side panel:",r),r}}async function e(s){try{let r=s.tab?.id;if(!r){const[S]=await a.tabs.query({active:!0,currentWindow:!0});r=S?.id}if(!r)throw new Error("No active tab found");const n=await a.tabs.get(r);if(n.url?.startsWith("browser://")||n.url?.startsWith("browser-extension://")||n.url?.startsWith("edge://")||n.url?.startsWith("about:"))throw new Error("이 페이지에서는 스크랩할 수 없습니다. (browser://, extension:// 등 제한된 페이지)");try{await a.tabs.sendMessage(r,{type:"PING"})}catch{await a.scripting.executeScript({target:{tabId:r},files:["content-scripts/content.js"]}),await new Promise(I=>setTimeout(I,500))}const o=await a.tabs.sendMessage(r,{type:"CLIP_PAGE",options:{includeMetadata:!0}});if(!o.success)throw new Error(o.error||"Clipping failed");const l={...o.data},f=l.tags||[],w=await O.quickScrap(l,"",f);try{a.runtime.sendMessage({action:"scrapCreated",data:w})}catch{}return w}catch(r){throw console.error("❌ Background: Clip and scrap failed:",r),r}}async function i(s){try{let r=s.tab?.id;if(!r){const[l]=await a.tabs.query({active:!0,currentWindow:!0});r=l?.id}if(!r)throw new Error("No active tab found");const n=await a.tabs.get(r);if(n.url?.startsWith("browser://")||n.url?.startsWith("browser-extension://")||n.url?.startsWith("edge://")||n.url?.startsWith("about:"))throw new Error("이 페이지에서는 스크랩할 수 없습니다. (browser://, extension:// 등 제한된 페이지)");try{await a.tabs.sendMessage(r,{type:"PING"})}catch{await a.scripting.executeScript({target:{tabId:r},files:["content-scripts/content.js"]}),await new Promise(f=>setTimeout(f,500))}const o=await a.tabs.sendMessage(r,{type:"CLIP_PAGE",options:{includeMetadata:!0}});if(!o.success)throw new Error(o.error||"Clipping failed");return o.data}catch(r){throw console.error("❌ Background: Clip for style failed:",r),r}}let u=!0;const h=async()=>{try{const s=await a.storage.sync.get(["tyquillSettings"]);s.tyquillSettings?.floatingButtonVisible!==void 0&&(u=s.tyquillSettings.floatingButtonVisible)}catch(s){console.error("설정 로드 실패:",s)}};a.storage.onChanged.addListener(s=>{s.tyquillSettings?.newValue?.floatingButtonVisible!==void 0&&(u=s.tyquillSettings.newValue.floatingButtonVisible,d())});const d=()=>{a.contextMenus.removeAll(),a.contextMenus.create({id:"tyquill",title:"Tyquill",contexts:["all"]}),a.contextMenus.create({id:"toggleFloatingButton",parentId:"tyquill",title:u?"👁️ 버튼 숨기기":"👁️‍🗨️ 버튼 표시하기",contexts:["all"]}),a.contextMenus.create({id:"separator1",parentId:"tyquill",type:"separator",contexts:["all"]}),a.contextMenus.create({id:"scrapCurrentPage",parentId:"tyquill",title:"📋 이 페이지 스크랩",contexts:["all"]})};a.contextMenus.onClicked.addListener(async(s,r)=>{if(r?.id)switch(s.menuItemId){case"toggleFloatingButton":try{const n=!u,l={...(await a.storage.sync.get(["tyquillSettings"])).tyquillSettings,floatingButtonVisible:n};await a.storage.sync.set({tyquillSettings:l}),u=n;const f=await a.tabs.query({});for(const w of f)if(w.id)try{await a.tabs.sendMessage(w.id,{type:"SETTINGS_CHANGED",settings:{floatingButtonVisible:n}})}catch{}d()}catch(n){console.error("플로팅 버튼 설정 변경 실패:",n)}break;case"scrapCurrentPage":try{await e({tab:r})}catch(n){console.error("스크랩 실패:",n)}break}}),a.runtime.onInstalled.addListener(async()=>{await h(),d()}),a.runtime.setUninstallURL("https://tally.so/r/3EOeqN")});function x(){}function y(c,...t){}const L={debug:(...c)=>y(console.debug,...c),log:(...c)=>y(console.log,...c),warn:(...c)=>y(console.warn,...c),error:(...c)=>y(console.error,...c)};let b;try{b=q.main(),b instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(c){throw L.error("The background crashed on startup!"),c}return b})();
