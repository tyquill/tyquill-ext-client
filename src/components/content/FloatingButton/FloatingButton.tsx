import React, { useEffect, useRef, useState, useCallback } from 'react';
import { clipAndScrapCurrentPage } from '../../../utils/scrapHelper';
import styles from './FloatingButton.module.css';
import { BsBook } from 'react-icons/bs';
import { IoClose } from 'react-icons/io5';
import { IoMdCheckmark } from 'react-icons/io';
import { motion } from 'framer-motion';
import Tooltip from '../../common/Tooltip'; // Tooltip Ïª¥Ìè¨ÎÑåÌä∏ import

// ÌÉÄÏûÖ Ï†ïÏùò
type ButtonStyle = {
  borderRadius: string;
  flexDirection: 'row' | 'row-reverse';
  width: string;
  height: string;
  padding: string;
  justifyContent: 'flex-start' | 'center';
  gap: string;
};

type ToolboxStyle = {
  backgroundColor: string;
  color: string;
  borderColor: string;
  opacity: number;
  pointerEvents: 'auto' | 'none';
  cursor: 'pointer' | 'wait';
  transform?: string;
};

type ToolGroup = {
  id: string;
  tools: Tool[];
  position: 'top' | 'bottom';
};

type Tool = {
  id: string;
  icon: React.ReactNode;
  label: string;
  action: () => void;
  shortcut?: string;
  tooltip?: string;
  disabled?: boolean;
};

const FloatingButton: React.FC = () => {
  const buttonRef = useRef<HTMLButtonElement>(null);
  const toolbarRef = useRef<HTMLDivElement>(null);
  const imgRef = useRef<HTMLImageElement>(null);
  
  const [isDragging, setIsDragging] = useState(false);
  const [hasMoved, setHasMoved] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [showSuccessAnimation, setShowSuccessAnimation] = useState(false);
  const [isSidePanelOpen, setIsSidePanelOpen] = useState(false); // ÏÇ¨Ïù¥ÎìúÌå®ÎÑê ÏÉÅÌÉú Ï∂îÍ∞Ä
  
  const [buttonPosition, setButtonPosition] = useState({
    top: '50%',
    right: '-40px',
    left: 'auto',
    transform: 'translateY(-50%)'
  });

  const [buttonStyle, setButtonStyle] = useState<ButtonStyle>({
    borderRadius: '32px 0 0 32px',
    flexDirection: 'row',
    width: 'auto',
    height: '36px',
    padding: '0 8px',
    justifyContent: 'flex-start',
    gap: '6px'
  });
  
  const [toolbarStyle, setToolbarStyle] = useState<ToolboxStyle>({
    backgroundColor: 'white',
    color: '#333',
    borderColor: 'rgba(0, 0, 0, 0.1)',
    opacity: 1,
    pointerEvents: 'auto',
    cursor: 'pointer'
  });

  const [settings, setSettings] = useState({
    floatingButtonVisible: true
  });

  const [buttonSide, setButtonSide] = useState<'left' | 'right'>('right');
  const [closeButtonPosition, setCloseButtonPosition] = useState({
    left: 'auto',
    right: '-6px'
  });

  const [isVisible, setIsVisible] = useState(true);

  const dragStartRef = useRef({ x: 0, y: 0, left: 0, top: 0 });
  const hiddenButtonWidth = 40;

  // ÏÇ¨Ïù¥ÎìúÌå®ÎÑê ÏÉÅÌÉú Í∞ÄÏ†∏Ïò§Í∏∞
  const getSidePanelState = useCallback(async (): Promise<boolean> => {
    try {
      const response = await chrome.runtime.sendMessage({ action: 'getSidePanelState' });
      return response?.isOpen || false;
    } catch (error) {
      // Extension context invalidatedÎäî Ï†ïÏÉÅÏ†ÅÏù∏ ÏÉÅÌô©Ïù¥ÎØÄÎ°ú Ï°∞Ïö©Ìûà Ï≤òÎ¶¨
      if (error instanceof Error && error.message.includes('Extension context invalidated')) {
        // console.log('Extension context invalidated - this is normal during extension reload');
        return false;
      }
      console.warn('‚ö†Ô∏è Content: Failed to get side panel state:', error);
      return false;
    }
  }, []);

  // ÏÇ¨Ïù¥ÎìúÌå®ÎÑê ÏÉÅÌÉú Ìè¥ÎßÅ
  useEffect(() => {
    const checkSidePanelStatus = async () => {
      const isOpen = await getSidePanelState();
      setIsSidePanelOpen(isOpen);
    };

    checkSidePanelStatus(); // Ï¥àÍ∏∞ ÌôïÏù∏
    const interval = setInterval(checkSidePanelStatus, 1000); // 1Ï¥àÎßàÎã§ ÌôïÏù∏

    return () => clearInterval(interval);
  }, [getSidePanelState]);


  // ÏÑ§Ï†ï Î°úÎìú Î∞è Î≥ÄÍ≤Ω Í∞êÏßÄ
  useEffect(() => {
    const loadSettings = () => {
      chrome.storage.sync.get(['tyquillSettings'], (result) => {
        if (result.tyquillSettings) {
          setSettings(prev => ({ ...prev, ...result.tyquillSettings }));
        }
      });
    };

    // Ï¥àÍ∏∞ ÏÑ§Ï†ï Î°úÎìú
    loadSettings();

    // ÏÑ§Ï†ï Î≥ÄÍ≤Ω Í∞êÏßÄ (Chrome Storage)
    const handleStorageChange = (changes: { [key: string]: chrome.storage.StorageChange }) => {
      if (changes.tyquillSettings) {
        setSettings(prev => ({ ...prev, ...changes.tyquillSettings.newValue }));
      }
    };

    // ÏÑ§Ï†ï Î≥ÄÍ≤Ω Í∞êÏßÄ (CustomEvent - Context MenuÏóêÏÑú Î≥ÄÍ≤Ω Ïãú)
    const handleSettingsChanged = (event: CustomEvent) => {
      if (event.detail) {
        setSettings(prev => ({ ...prev, ...event.detail }));
      }
    };

    chrome.storage.onChanged.addListener(handleStorageChange);
    window.addEventListener('tyquill-settings-changed', handleSettingsChanged as EventListener);

    return () => {
      chrome.storage.onChanged.removeListener(handleStorageChange);
      window.removeEventListener('tyquill-settings-changed', handleSettingsChanged as EventListener);
    };
  }, []);

  // Ïú†ÌäúÎ∏å Ï†ÑÏ≤¥ÌôîÎ©¥ Í∞êÏßÄ Ìï®Ïàò
  const checkYouTubeFullscreen = useCallback(() => {
    // Ïú†ÌäúÎ∏å Ï†ÑÏ≤¥ÌôîÎ©¥ Í∞êÏßÄ (Îçî Ï†ïÌôïÌïú Î∞©Î≤ï)
    const isYouTubeFullscreen = 
      document.fullscreenElement?.classList.contains('html5-video-player') ||
      document.fullscreenElement?.tagName === 'VIDEO' ||
      document.fullscreenElement?.classList.contains('ytp-fullscreen') ||
      document.querySelector('.ytp-fullscreen') !== null ||
      document.querySelector('.html5-video-player.ytp-fullscreen') !== null ||
      document.querySelector('.ytp-fullscreen-button[aria-pressed="true"]') !== null ||
      document.querySelector('.ytp-fullscreen-button.ytp-button[aria-pressed="true"]') !== null ||
      document.querySelector('.ytp-fullscreen') !== null ||
      document.querySelector('.ytp-fullscreen-button.ytp-button')?.getAttribute('aria-pressed') === 'true' ||
      document.querySelector('.ytp-fullscreen-button')?.getAttribute('aria-pressed') === 'true';

    // ÏùºÎ∞ò Ï†ÑÏ≤¥ÌôîÎ©¥ Í∞êÏßÄ
    const isGeneralFullscreen = !!document.fullscreenElement;

    // Ïú†ÌäúÎ∏å ÌéòÏù¥ÏßÄÏóêÏÑú Ï†ÑÏ≤¥ÌôîÎ©¥ Î™®ÎìúÏù∏ÏßÄ ÌôïÏù∏
    const isYouTubePage = window.location.hostname.includes('youtube.com') || 
                         window.location.hostname.includes('youtu.be');
    
    // Ï∂îÍ∞ÄÏ†ÅÏù∏ Ïú†ÌäúÎ∏å Ï†ÑÏ≤¥ÌôîÎ©¥ Í∞êÏßÄ
    const youtubeFullscreenButton = document.querySelector('.ytp-fullscreen-button');
    const isYouTubeFullscreenActive = youtubeFullscreenButton?.getAttribute('aria-pressed') === 'true';
    
    const shouldHide = (isYouTubePage && (isYouTubeFullscreen || isYouTubeFullscreenActive)) || isGeneralFullscreen;
    
    // console.log('üîç Ïú†ÌäúÎ∏å Ï†ÑÏ≤¥ÌôîÎ©¥ Í∞êÏßÄ:', {
    //   isYouTubePage,
    //   isYouTubeFullscreen,
    //   isYouTubeFullscreenActive,
    //   isGeneralFullscreen,
    //   shouldHide
    // });
    
    setIsVisible(!shouldHide);
  }, []);

  // ÌòÑÏû¨ Î≤ÑÌäº ÏúÑÏπò ÌôïÏù∏ Î∞è ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
  const getCurrentSide = useCallback((): 'left' | 'right' => {
    if (!buttonRef.current) return 'right';
    const computedStyle = getComputedStyle(buttonRef.current);
    const currentSide = computedStyle.right === 'auto' ||
      computedStyle.left.startsWith('-')
      ? 'left'
      : 'right';
    
    // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
    setButtonSide(currentSide);
    return currentSide;
  }, []);

  // Îã´Í∏∞ Î≤ÑÌäº ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
  const updateCloseButtonPosition = useCallback(() => {
    setCloseButtonPosition({
      left: buttonSide === 'left' ? 'auto' : '-6px',
      right: buttonSide === 'left' ? '-6px' : 'auto'
    });
  }, [buttonSide]);

  // Î≤ÑÌäº ÏúÑÏπò Î≥ÄÍ≤Ω Ïãú Îã´Í∏∞ Î≤ÑÌäº ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
  useEffect(() => {
    updateCloseButtonPosition();
  }, [buttonSide, updateCloseButtonPosition]);

  // ÏÑ§Ï†ï Î≥ÄÍ≤Ω Ïãú hover ÏÉÅÌÉú Î¶¨ÏÖã
  useEffect(() => {
    if (settings.floatingButtonVisible) {
      // ÌîåÎ°úÌåÖ Î≤ÑÌäºÏù¥ Îã§Ïãú ÌëúÏãúÎê† Îïå hover ÏÉÅÌÉú Î¶¨ÏÖã
      setButtonPosition(prev => ({
        ...prev,
        transform: prev.top === '50%' ? 'translateY(-50%)' : 'none'
      }));
    }
  }, [settings.floatingButtonVisible]);

  // Ìà¥Î∞î ÏúÑÏπò Í≥ÑÏÇ∞ (CSS left/right ÏÜçÏÑ± ÏÇ¨Ïö©)
  const positionToolbar = useCallback(() => {
    if (!buttonRef.current || !toolbarRef.current) return;

    const buttonRect = buttonRef.current.getBoundingClientRect();
    
    // Î≤ÑÌäºÏùò Ïã§Ï†ú ÏúÑÏπòÎ•º Í∏∞Î∞òÏúºÎ°ú Ïò§Î•∏Ï™Ω/ÏôºÏ™Ω ÌåêÎã®
    const buttonCenterX = buttonRect.left + buttonRect.width / 2;
    const isRightSide = buttonCenterX > window.innerWidth / 2;
    
    // Ìà¥Î∞îÎ•º Î©îÏù∏ Î≤ÑÌäº ÏúÑÏóê Î∞∞Ïπò
    const toolbarTop = buttonRect.top - 44; // Ìà¥Î∞î ÎÜíÏù¥(36px) + Í∞ÑÍ≤©(8px)

    // CSS left/right ÏÜçÏÑ±ÏúºÎ°ú Ìà¥Î∞î ÏúÑÏπò ÏÑ§Ï†ï
    if (isRightSide) {
      // Ïò§Î•∏Ï™ΩÏóê ÏûàÏùÑ ÎïåÎäî right: 0; left: auto;
      toolbarRef.current.style.right = '0';
      toolbarRef.current.style.left = 'auto';
    } else {
      // ÏôºÏ™ΩÏóê ÏûàÏùÑ ÎïåÎäî left: 0; right: auto;
      toolbarRef.current.style.left = '0';
      toolbarRef.current.style.right = 'auto';
    }
    
    toolbarRef.current.style.top = `${toolbarTop}px`;
  }, []);

  // Ìò∏Î≤Ñ Ìö®Í≥º Ï≤òÎ¶¨
  const handleHover = useCallback((isEntering: boolean) => {
    const currentSide = getCurrentSide();
    // ÎìúÎûòÍ∑∏ ÌõÑÏóêÎèÑ translateY(-50%)Î•º Ïú†ÏßÄÌïòÍ∏∞ ÏúÑÌï¥ Ï°∞Í±¥ ÏàòÏ†ï
    const yTransform = buttonPosition.top === '50%' || buttonPosition.transform?.includes('translateY(-50%)') ? 'translateY(-50%)' : '';
    
    if (currentSide === 'left') {
      const xTransform = isEntering ? `translateX(${hiddenButtonWidth}px)` : '';
      const scale = isEntering ? 'scale(1.02)' : 'scale(1)';
      setButtonPosition(prev => ({ ...prev, transform: [yTransform, xTransform, scale].filter(Boolean).join(' ') }));
    } else {
      const xTransform = isEntering ? `translateX(-${hiddenButtonWidth}px)` : '';
      const scale = isEntering ? 'scale(1.02)' : 'scale(1)';
      setButtonPosition(prev => ({ ...prev, transform: [yTransform, xTransform, scale].filter(Boolean).join(' ') }));
    }
  }, [buttonPosition.top, buttonPosition.transform, getCurrentSide]);

  // ÎßàÏö∞Ïä§ Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨Îì§
  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    setIsDragging(true);
    setHasMoved(false);

    if (!buttonRef.current) return;

    const rect = buttonRef.current.getBoundingClientRect();
    dragStartRef.current = {
      x: e.clientX,
      y: e.clientY,
      left: rect.left,
      top: rect.top
    };

    e.preventDefault();
  }, []);

  const handleMouseMove = useCallback((e: MouseEvent) => {
    if (!isDragging || !buttonRef.current) return;

    const deltaX = e.clientX - dragStartRef.current.x;
    const deltaY = e.clientY - dragStartRef.current.y;

    if (!hasMoved && (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10)) {
      setHasMoved(true);
      
      // Ïã§Ï†ú ÎìúÎûòÍ∑∏Í∞Ä ÏãúÏûëÎê† Îïå Ìà¥Î∞î ÏôÑÏ†ÑÌûà Ïà®Í∏∞Í∏∞
      if (toolbarRef.current) {
        toolbarRef.current.style.opacity = '0';
        toolbarRef.current.style.pointerEvents = 'none';
        toolbarRef.current.style.visibility = 'hidden';
      }
      
      // ÎìúÎûòÍ∑∏ Ïä§ÌÉÄÏùº Ï†ÅÏö©
      setButtonStyle({
        borderRadius: '50%',
        flexDirection: 'row',
        width: '40px',
        height: '40px',
        padding: '8px',
        justifyContent: 'center',
        gap: '0px'
      });

      setButtonPosition({
        top: `${dragStartRef.current.top}px`,
        left: `${dragStartRef.current.left}px`,
        right: 'auto',
        transform: 'none'
      });
    }

    if (hasMoved) {
      const newLeft = dragStartRef.current.left + deltaX;
      const newTop = dragStartRef.current.top + deltaY;

      const maxLeft = window.innerWidth - 40;
      const maxTop = window.innerHeight - 40;

      const finalLeft = Math.max(0, Math.min(newLeft, maxLeft));
      const finalTop = Math.max(0, Math.min(newTop, maxTop));

      setButtonPosition({
        top: `${finalTop}px`,
        left: `${finalLeft}px`,
        right: 'auto',
        transform: 'none'
      });

      // ÎìúÎûòÍ∑∏ Ï§ëÏóêÎäî Ìà¥Î∞î Ïà®Í∏∞Í∏∞ (Ïù¥ÎØ∏ handleMouseMoveÏóêÏÑú Ï≤òÎ¶¨Îê®)
    }
  }, [isDragging, hasMoved]);

  const handleMouseUp = useCallback(() => {
    if (!isDragging) return;

    setIsDragging(false);
    
    if (hasMoved && buttonRef.current) {
      // Ïã§Ï†ú ÎìúÎûòÍ∑∏Í∞Ä Î∞úÏÉùÌïú Í≤ΩÏö∞
      setHasMoved(false); // ÎìúÎûòÍ∑∏ ÏôÑÎ£å ÌõÑ hasMoved Î¶¨ÏÖã
      const rect = buttonRef.current.getBoundingClientRect();
      const isLeftSide = (rect.left + rect.width / 2) < window.innerWidth / 2;
      const currentTop = rect.top;

      setButtonStyle({
        borderRadius: isLeftSide ? '0 32px 32px 0' : '32px 0 0 32px',
        flexDirection: isLeftSide ? 'row-reverse' : 'row',
        width: 'auto',
        height: '36px',
        padding: '0 8px',
        justifyContent: 'flex-start',
        gap: '6px'
      });

      setButtonPosition({
        top: `${currentTop}px`,
        left: isLeftSide ? `-${hiddenButtonWidth}px` : 'auto',
        right: isLeftSide ? 'auto' : `-${hiddenButtonWidth}px`,
        transform: 'translateY(-50%)'
      });

      // Ìà¥Î∞î Îã§Ïãú ÌëúÏãú
      setTimeout(() => {
        if (toolbarRef.current) {
          // Ìà¥Î∞î ÏßÅÏ†ë ÌëúÏãú
          toolbarRef.current.style.opacity = '1';
          toolbarRef.current.style.pointerEvents = 'auto';
          toolbarRef.current.style.visibility = 'visible';
          positionToolbar();
        }
      }, 300);
    }
  }, [isDragging, hasMoved, positionToolbar]);

  // ÏÇ¨Ïù¥ÎìúÌå®ÎÑê Ïó¥Í∏∞/Îã´Í∏∞
  const openSidePanel = useCallback(async () => {
    await chrome.runtime.sendMessage({ action: 'openSidePanel' });
    setIsSidePanelOpen(true);
  }, []);

  const closeSidePanel = useCallback(async () => {
    await chrome.runtime.sendMessage({ action: 'closeSidePanel' });
    setIsSidePanelOpen(false);
  }, []);

  // Ïä§ÌÅ¨Îû© Ï≤òÎ¶¨
  const handleScrap = useCallback(async () => {
    if (isLoading) return;
    setIsLoading(true);
    setToolbarStyle(prev => ({ ...prev, opacity: 0.7, pointerEvents: 'none', cursor: 'wait' }));

    try {
      await clipAndScrapCurrentPage();

      // ÏÑ±Í≥µ Ïï†ÎãàÎ©îÏù¥ÏÖò ÌëúÏãú
      setShowSuccessAnimation(true);
      setToolbarStyle(prev => ({ ...prev, backgroundColor: '#10b981', color: 'white', borderColor: '#10b981' }));
    } catch (error) {
      setToolbarStyle(prev => ({ ...prev, backgroundColor: '#ef4444', color: 'white', borderColor: '#ef4444' }));
      console.error('‚ùå Ïä§ÌÅ¨Îû© Ïã§Ìå®:', error);
    } finally {
      setIsLoading(false);
      setTimeout(() => {
        setToolbarStyle({
          backgroundColor: 'white', color: '#333', borderColor: 'rgba(0, 0, 0, 0.1)',
          opacity: 1, pointerEvents: 'auto', cursor: 'pointer'
        });
        setShowSuccessAnimation(false);
      }, 3000);
    }
  }, [isLoading]);

  // Ìà¥ Í∑∏Î£π Ï†ïÏùò
  const toolGroups: ToolGroup[] = [{
    id: 'main', position: 'top',
    tools: [{
      id: 'scrap', icon: <BsBook size={18} />, label: 'Ïä§ÌÅ¨Îû©', action: handleScrap,
      shortcut: '‚åòS', tooltip: 'ÌòÑÏû¨ ÌéòÏù¥ÏßÄ Ïä§ÌÅ¨Îû©ÌïòÍ∏∞'
    }]
  }];

  // Î©îÏù∏ Î≤ÑÌäº ÌÅ¥Î¶≠
  const handleButtonClick = useCallback(async () => {
    if (hasMoved || isDragging) return;
    isSidePanelOpen ? await closeSidePanel() : await openSidePanel();
  }, [hasMoved, isDragging, isSidePanelOpen, openSidePanel, closeSidePanel]);

  // Îã´Í∏∞ Î≤ÑÌäº ÌÅ¥Î¶≠
  const handleCloseButtonClick = useCallback(async (e: React.MouseEvent) => {
    e.stopPropagation();
    try {
      const { tyquillSettings } = await chrome.storage.sync.get('tyquillSettings');
      await chrome.storage.sync.set({
        tyquillSettings: { ...tyquillSettings, floatingButtonVisible: false }
      });
    } catch (error) {
      console.error('ÌîåÎ°úÌåÖ Î≤ÑÌäº Ïà®ÍπÄ ÏÑ§Ï†ï Ïã§Ìå®:', error);
    }
  }, []);

  // Ìà¥ ÌÅ¥Î¶≠ Ìï∏Îì§Îü¨
  const handleToolClick = useCallback((tool: Tool) => {
    if (tool.disabled) return;
    tool.action();
  }, []);

  // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
  useEffect(() => {
    const handleGlobalMouseMove = (e: MouseEvent) => handleMouseMove(e);
    const handleGlobalMouseUp = () => handleMouseUp();

    if (isDragging) {
      document.addEventListener('mousemove', handleGlobalMouseMove);
      document.addEventListener('mouseup', handleGlobalMouseUp);
    }

    return () => {
      document.removeEventListener('mousemove', handleGlobalMouseMove);
      document.removeEventListener('mouseup', handleGlobalMouseUp);
    };
  }, [isDragging, handleMouseMove, handleMouseUp]);

  // Ï¥àÍ∏∞ Î≤ÑÌäº ÏúÑÏπò ÏÉÅÌÉú ÏÑ§Ï†ï Î∞è Î≤ÑÌäº ÌëúÏãú ÏÉÅÌÉú Î≥ÄÍ≤Ω Ïãú Ìà¥Î∞î ÏúÑÏπò Ïû¨Í≥ÑÏÇ∞
  useEffect(() => {
    const timer = setTimeout(() => {
      // Ï¥àÍ∏∞ Î≤ÑÌäº ÏúÑÏπò ÏÉÅÌÉú ÏÑ§Ï†ï
      getCurrentSide();
      // Ìà¥Î∞î ÏúÑÏπò ÏÑ§Ï†ï
      positionToolbar();
    }, 100);
    return () => clearTimeout(timer);
  }, [getCurrentSide, positionToolbar, settings.floatingButtonVisible]);

  // Ï†ÑÏ≤¥ÌôîÎ©¥ ÏÉÅÌÉú Í∞êÏßÄ
  useEffect(() => {
    const handleFullscreenChange = () => checkYouTubeFullscreen();
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    // ... (other fullscreen listeners)
    const observer = new MutationObserver(() => checkYouTubeFullscreen());
    observer.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ['class', 'aria-pressed'] });

    checkYouTubeFullscreen();

    return () => {
      document.removeEventListener('fullscreenchange', handleFullscreenChange);
      // ... (other fullscreen listeners)
      observer.disconnect();
    };
  }, [checkYouTubeFullscreen]);

  // Î≤ÑÌäºÏù¥ Ïà®Í≤®Ï†∏Ïïº ÌïòÎäî Í≤ΩÏö∞ Î†åÎçîÎßÅÌïòÏßÄ ÏïäÏùå
  if (!settings.floatingButtonVisible || !isVisible) {
    return null;
  }

  return (
    <>
      <button
        ref={buttonRef}
        id="tyquill-floating-button"
        className={`${styles.floatingButton} ${isDragging ? styles.dragging : ''} ${hasMoved ? styles.moved : ''}`}
        style={{ ...buttonPosition, ...buttonStyle }}
        onMouseEnter={() => !isDragging && !isLoading && handleHover(true)}
        onMouseLeave={() => !isDragging && !isLoading && handleHover(false)}
        onMouseDown={handleMouseDown}
        onClick={handleButtonClick}
      >
        <img
          ref={imgRef}
          src="https://4bvbvpozg7fnspb5.public.blob.vercel-storage.com/Gemini_Generated_Image_y6f5u2y6f5u2y6f5.png"
          className={styles.logoImage}
          draggable={false}
        />
        
        <button
          className={styles.closeButton}
          style={closeButtonPosition}
          onClick={handleCloseButtonClick}
          aria-label="ÌîåÎ°úÌåÖ Î≤ÑÌäº Ïà®Í∏∞Í∏∞"
        >
          <IoClose size={12} />
        </button>
      </button>

      {/* Monica Ïä§ÌÉÄÏùº Ìà¥Î∞î */}
      <div
        ref={toolbarRef}
        id="tyquill-toolbar"
        className={styles.toolbar}
        style={{ opacity: 1, pointerEvents: 'auto' }}
      >
        <div className={styles.toolGroup}>
          {toolGroups.map((group) => (
            <div key={group.id} className={styles.wrapper}>
              <div className={styles.expandActionTool}>
                {group.tools.map((tool) => (
                   <Tooltip key={tool.id} content={tool.tooltip || ''} side={buttonSide === 'left' ? 'right' : 'left'}>
                    <motion.div 
                      className={styles.nodeWrapper}
                      onClick={() => handleToolClick(tool)}
                      animate={showSuccessAnimation && tool.id === 'scrap' ? {
                        scale: [1, 1.2, 1], backgroundColor: ["#ffffff", "#10b981", "#ffffff"],
                      } : {}}
                      transition={{ duration: 0.8, ease: "easeOut" }}
                    >
                      <motion.div 
                        className={styles.actionMenuInner}
                        animate={showSuccessAnimation && tool.id === 'scrap' ? {
                          color: ["#666", "#ffffff", "#666"]
                        } : {}}
                        transition={{ duration: 0.8, ease: "easeOut" }}
                      >
                        {showSuccessAnimation && tool.id === 'scrap' ? (
                          <motion.div initial={{ scale: 0 }} animate={{ scale: 1 }} transition={{ duration: 0.3, delay: 0.2 }}>
                            <IoMdCheckmark size={18} />
                          </motion.div>
                        ) : ( tool.icon )}
                      </motion.div>
                    </motion.div>
                  </Tooltip>
                ))}
              </div>
            </div>
          ))}
        </div>
      </div>
    </>
  );
};

export default FloatingButton;
